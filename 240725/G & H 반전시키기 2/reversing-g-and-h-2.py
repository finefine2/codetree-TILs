n = int(input())
st = list(input())
target = list(input())

ans = 0
for i in range(len(st)-1, -1, -1):
    if st[i] != target[i]:
        for j in range(0, i+1):
            if st[j] == 'G':
                st[j] = 'H'
            elif st[j] == 'H':
                st[j] = 'G'
        
        ans += 1

print(ans)

# 답안 처럼 이러한 방법을 사용하면 시간복잡도가 줄어들 것이다.
# 답안처럼 이렇게 작성하면 이중 for문을 작성하지 않아도 되어서 시간이 줄어든다.
# cnt로 반전하는 횟수를 늘리면서 
# 만약 이제까지 짝수번 눌렸는데 다를 경우에는 바꾸어야 하므로 cnt를 늘려주고, 
# 홀수번 눌렸는데 같아서 영향을 주는 경우에도 바꾸어 주어야 하므로 한번 더 추가하는 방법으로 선택한다.
# → 위의 내 방법대로 하면 시간 초과가 날 것이고 누구나 할 수 있는 풀이지만
# 밑의 풀이처럼 뒤에서부터 돌면서 눌렀던 횟수를 고려하고, 문자에 영향을 주는지를 생각해보면서 cnt 자체만 더해주어도 가능한 경우를 사용하는 것이 좋다.

# for i in range(n - 1, -1, -1):
#     # 두 문자가 다른 경우이면서
#     # 지금까지 뒤에서 눌렀던 횟수가 짝수번이라
#     # i번째 문자에 영향을 주지 못하는 경우라면
#     # 현재 위치를 선택해줘야 합니다.
#     if a[i] != b[i] and cnt % 2 == 0:
#         cnt += 1
    
#     # 두 문자가 같은 경우이면서
#     # 지금까지 뒤에서 놀렀던 횟수가 홀수번이라
#     # i번째 문자에 영향을 주는 경우라면
#     # 현재 위치를 선택해줘야 합니다.
#     elif a[i] == b[i] and cnt % 2 == 1:
#         cnt += 1